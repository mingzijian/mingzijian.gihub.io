Synchronized & Lock & Volatile

--------------------------------------------------------

### Synchronized

#### 应用方式

-  修饰实例方法 

  <pre> 作用于当前实例加锁，进入同步代码前要获得当前实例的锁。 </pre>

-  修饰静态方法 

  <pre> 作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁。 </pre>

-  修饰代码块 

  <pre> 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。 </pre>

#### 底层原理

##### 关键概念

-  `Monitor`

-  `Mark Word`

   ##### `monitorenter`&` monitorexit `  

  ##### ` ACC_SYNCHRONIZED `



#### Java虚拟机对synchronized的优化



#### 可重入性



#### 线程中断



#### 使用场景



### Lock

####  ReentrantLock （可重入锁）



####  ReentrantReadWriteLock （可重入读写锁）





### Volatile

####  两层语义

-  保证可见

  <pre>
  保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 ( 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行) 
  </pre>

  
-  禁止重排

  <pre>
  禁止进行指令重排序。( 在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。 ) 
  </pre>

  

#### 底层实现

“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”

　　lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：

　　1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；

　　2）它会强制将对缓存的修改操作立即写入主存；

　　3）如果是写操作，它会导致其他CPU中对应的缓存行无效。



#### 使用场景

- 状态标记
- 双重检查

