Java 锁
-----------

### 锁分类

#### 按 “线程是否需要锁同步资源” 来分
- 悲观锁
- 乐观锁



#### 按 “锁同步资源失败，是否需要阻塞线程” 来分
- 非自旋锁
- 自旋锁

#### 按 “多个锁竞争同步资源的流程区别” 来分

- 偏向锁
- 轻量级锁（自旋锁）
- 重量级锁

#### 按 “多个线程竞争锁时是否需要排队” 来分
- 公平锁
- 非公平锁

#### 按 “一个线程中多个流程是否能获取同一把锁” 来分
- 可重入锁
- 非可重入锁

#### 按 “多个线程是否能共享一把锁” 来分
- 共享锁
- 排他锁

  
### AQS
#### 简介
	`AQS`的全称为`AbstractQuenedSynchronizer`（抽象的队列式同步器）。
	该类在`rt.jar`的`java.util.concurrent.locks`包中。
#### 核心思想
	如果被请求的共享资源空闲，则将当前请求资源的线程设置未有效的工作线程，并将共享资源设置为锁定状态；
	如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即：将暂时获取不到锁的线程加入到队列中。
	CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列，即：不存在队列实例，仅存在节点之间的关联关系。
	AQS是将每一条请求共享资源的线程封装成一个CLH锁队列的一个节点（Node）,来实现锁的分配。即：用volatile关键字修饰共享变量state，线程通过CAS去改变state，成功则获得锁，失败则进入等待队列，等待被唤醒。
  
  