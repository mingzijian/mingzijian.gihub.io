Dubbo 心跳检测
-----------------

#### 空闲检测
忙检测的对立面是空闲检测，我们做心跳的初衷，是为了保证连接的可用性，以保证及时采取断连，重连等措施。如果一条通道上有频繁的 RPC 调用正在进行，我们不应该为通道增加负担去发送心跳包。心跳扮演的角色应当是**晴天收伞，雨天送伞**。

#### 心跳检测容错
网络通信永远要考虑到最坏的情况，一次心跳失败，不能认定为连接不通，多次心跳失败，才能采取相应的措施

#### 双向心跳检测
服务端会向客户端发送心跳，客户端也会向服务端发送心跳，接收的一方更新 lastRead 字段，发送的一方更新 lastWrite 字段，超过心跳间隙的时间，便发送心跳请求给对端。这里的 lastRead/lastWrite 同样会被同一个通道上的普通调用更新，通过更新这两个字段，实现了只在连接空闲时才会真正发送空闲报文的机制，符合我们一开始科普的做法。
**注意**不仅仅心跳请求会更新 lastRead 和 lastWrite，普通请求也会。这对应了我们预备知识中的空闲检测机制。

#### 断连与重连
根据客户端、服务端类型来对连接做不同的处理。
当超过设置的心跳总时间之后，客户端选择的是重新连接，服务端则是选择直接断开连接。这样的考虑是合理的，客户端调用是强依赖可用连接的，而服务端可以等待客户端重新建立连接。

#### 心跳总结
Dubbo 对于建立的每一个连接，同时在客户端和服务端开启了 2 个定时器，一个用于定时发送心跳，一个用于定时重连、断连，执行的频率均为各自检测周期的 1/3。
定时发送心跳的任务负责在连接空闲时，向对端发送心跳包。
定时重连、断连的任务负责检测 lastRead 是否在超时周期内仍未被更新，如果判定为超时，客户端处理的逻辑是重连，服务端则采取断连的措施。

#### 改进方案

|         对比         |                        Dubbo 现有方案                        | Dubbo 改进方案                                       |
| :------------------: | :----------------------------------------------------------: | ---------------------------------------------------- |
|     **主体设计**     |                        开启两个定时器                        | 借助 IdleStateHandler，底层使用 schedule             |
|     **心跳方向**     |                             双向                             | 单向（客户端 -> 服务端）                             |
| **心跳失败判定方式** | 心跳成功更新标记，借助定时器定时扫描标记，如果超过心跳超时周期未更新标记，认为心跳失败。 | 通过判断心跳响应是否失败，超过失败次数，认为心跳失败 |
|      **扩展性**      | Dubbo 存在 mina，grizzy 等其他通信层实现，自定义定时器很容易适配多种扩展 | 多通信层各自实现心跳，不做心跳的抽象                 |
|      **设计性**      |          编码复杂度高，代码量大，方案复杂，不易维护          | 编码量小，可维护性强                                 |


### 参考
- http://dubbo.apache.org/zh-cn/blog/dubbo-heartbeat-design.html